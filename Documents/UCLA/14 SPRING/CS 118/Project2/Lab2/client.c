#include <stdio.h>#include <sys/types.h>#include <sys/socket.h>#include <netinet/in.h>#include <netdb.h>      // define structures like hostent#include <stdlib.h>#include <string.h>#include <time.h>#include "packet.h"void error(char *msg){    perror(msg);    exit(0);}int loss_or_corrupted(int probability, int i){	srand(time(NULL)+i);	int a = rand()%100;	return probability > a;}void print(struct packet* pck){	if (pck->packetType == 0){		printf("Client:		Client request file %s with size %d \n", pck->file, pck->size);		return;	}	else if (pck->packetType == 1){		printf("Client:		ACK sent seq#%d, ACK#%d, FIN 0, content-length: 0\n", pck->seqNum, pck->ackNum);	}	else if (pck->packetType == 2){		printf("Client:		DATA received seq#%d, ACK#%d, FIN 0, content-length: %d\n", pck->seqNum, pck->ackNum, pck->size);	}	else if (pck->packetType == 4){		printf("Client:		File does not exist on the server side. ]n");	}	else{		printf("Client:		FINACK sent seq#%d, ACK#%d, FIN 1, content-length: 0\n", pck->seqNum, pck->ackNum);	}}/*int selectFunc(struct timeval timeout, fd_set rset, int sockfd){	FD_ZERO(&rset);	FD_SET(sockfd, &rset);	timeout.tv_sec = 1; //2 second timeout	timeout.tv_usec = 0;	return select(sockfd+1, &rset, NULL, NULL, &timeout);}*/int main(int argc, char *argv[]){    int sockfd; //Socket descriptor	char filename[100];    int portno, n;	int r;    struct sockaddr_in serv_addr;	int serv_len;    struct hostent *server; //contains tons of information, including the server's IP address	struct packet req_pckt, recv_pckt, resp_pckt;	double p_loss, p_corruption;	int loss, corrupted;	int exp_seq, num_pkt;	int rand_counter;	FILE *result;    if (argc < 5) {       fprintf(stderr,"argument format: server_hostname server_port_number filename prob_loss prob_corruption\n");       exit(0);    }        portno = atoi(argv[2]);    sockfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP); //create a new socket    if (sockfd < 0)         error("ERROR opening socket\n");        server = gethostbyname(argv[1]);     if (server == NULL) {        fprintf(stderr,"ERROR, no such host\n");        exit(0);    }		p_loss = atof(argv[4])*100;	p_corruption = atof(argv[5])*100;	memset(filename, 0, 100);	strcpy(filename, argv[3]);    bzero((char*) &serv_addr, sizeof(serv_addr));    serv_addr.sin_family = AF_INET; //initialize server's address    bcopy((char*)server->h_addr, (char *)&serv_addr.sin_addr.s_addr, server->h_length);    serv_addr.sin_port = htons(portno);    	// establish a connection to the server    if (connect(sockfd,(struct sockaddr *)&serv_addr,sizeof(serv_addr)) < 0)         error("ERROR connecting\n");    	//create request packet	req_pckt.packetType = 0;	memset(req_pckt.file, '\0', sizeof(req_pckt.file));	strncpy(req_pckt.file, filename, strlen(filename));    req_pckt.size = strlen(filename);	req_pckt.ackNum = 0;	req_pckt.seqNum = 0;	req_pckt.fin = 0;	serv_len = sizeof(serv_addr);	//send request packet	int timed = 0;	struct timeval timeout;	fd_set rset;/* -------------------------------------  modify this! ------------------------------------- */	while(timed == 0){		r = sendto(sockfd, &req_pckt, sizeof(struct packet),0, (struct sockaddr*) &serv_addr, serv_len); //send to socket		print(&req_pckt);		if (r < 0)			error("error sending the request\n");		do{			timed = selectFunc(timeout, rset, sockfd);		} while (timed < 0);			}	//received ACK for request packet, set timer if the ack packet is not received	r = recvfrom(sockfd, &recv_pckt, sizeof(struct packet), 0, (struct sockaddr*) &serv_addr, &serv_len);	//received packet that wasn't ACK	if(recv_pckt.packetType != 1){		print(&recv_pckt);   	}/* -------------------------------------  modify this! ------------------------------------- */	num_pkt = strlen(filename)+1; //starting sequence number	exp_seq= 0; // expected sequence number that will be the ack num	// create a file to write the result	result = fopen("result", "wb");	// initialize the first respond packet 	resp_pckt.ackNum = exp_seq;	resp_pckt.seqNum = num_pkt;	resp_pckt.size = 0;	resp_pckt.packetType = 1;	resp_pckt.fin = 0;	while(1)	{		timed = 0;		while (exp_seq && timed == 0 && !loss && !corrupted){				sendto(sockfd, &resp_pckt, sizeof(struct packet), 0, (struct sockaddr*) &serv_addr, serv_len);				print(&resp_pckt);				do				{					timed = selectFunc(timeout, rset, sockfd);				} while (timed < 0);				if (timed == 0) 				{					printf("Client: 	TIMEOUT, resend ACK \n");				}		}		r = recvfrom(sockfd, &recv_pckt, sizeof(struct packet), 0, (struct sockaddr*) &serv_addr, &serv_len);				loss = loss_or_corrupted(p_loss, num_pkt);		corrupted = loss_or_corrupted(p_corruption, num_pkt);		if (r > 0 && !loss && !corrupted && exp_seq == recv_pckt.seqNum) // Data successfully received		{			if(recv_pckt.fin != 1)			{				print(&recv_pckt);				fwrite(recv_pckt.file, 1, recv_pckt.size, result);				exp_seq+=recv_pckt.size;			}			else 			{								printf("Client:		FIN received seq#%d, ACK#%d, FIN 1, content-length: %d\n", recv_pckt.seqNum, recv_pckt.ackNum, recv_pckt.size);				exp_seq++;			}						// prepare the respond ack packet			resp_pckt.ackNum = exp_seq;			resp_pckt.seqNum = num_pkt++;			resp_pckt.size = 0;			resp_pckt.packetType = 1;			resp_pckt.fin = 0;			if (recv_pckt.fin) //reach the end of the packet, prepare to close			{				rand_counter = 0; // keep track of the proabability of lost FINACK packet				loss = loss_or_corrupted(p_loss, num_pkt);				corrupted = loss_or_corrupted(p_corruption, num_pkt);				printf("Client:		File transfer complete \n");				// prepare fin-ack packet				resp_pckt.packetType = 3;				resp_pckt.fin = 1;				do				{					if (rand_counter)					{						printf("Client:		DATA is lost or corrupted. Expect seq#%d \n", exp_seq);						usleep(5000);					}					//send FINACK, set on timer					timed = 0;					while (timed == 0){						sendto(sockfd, &resp_pckt, sizeof(struct packet), 0, (struct sockaddr*) &serv_addr, serv_len);						print(&resp_pckt);						do						{							timed = selectFunc(timeout, rset, sockfd);						} while (timed < 0);					}									r = recvfrom(sockfd, &recv_pckt, sizeof(struct packet), 0, (struct sockaddr*) &serv_addr, &serv_len);					loss = loss_or_corrupted(p_loss, rand_counter++);					corrupted = loss_or_corrupted(p_corruption, rand_counter++);									}while (r < 0 || loss || corrupted || exp_seq != recv_pckt.seqNum); 				printf("Client:		FINACK received seq#%d, ACK#%d, FIN 1, content-length: 0\n", recv_pckt.seqNum, recv_pckt.ackNum);				break;			}			//sendto(sockfd, &resp_pckt, sizeof(struct packet), 0, (struct sockaddr*) &serv_addr, serv_len); //TO DO ERROR			//print(&resp_pckt);					}		else // discard the packet		{			if (loss || r < 0) printf("Client:		DATA is lost. Expect seq#%d \n", exp_seq);			else if (corrupted) printf("Client:		 DATA is corrupted. seq#%d \n", exp_seq);		}	}    	fclose(result);    close(sockfd); //close socket	printf("Client:		close connection \n");        return 0;}